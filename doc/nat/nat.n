.pl 10.0i
.po 0
.ll 7.2i
.lt 7.2i
.nr LL 7.2i
.nr LT 7.2i
.ds LF Ford
.ds RF FORMFEED[Page %]
.ds CF
.ds LH draft-ford-p2pmid-00.txt
.ds RH April 2003
.ds CH
.hy 0
.ad l
Internet Draft                                                   B. Ford
Document: draft-ford-p2pmid-00.txt                                M.I.T.
Expires: October 2003                                       P. Srisuresh
                                                                     XXX
                                                                D. Kegel
                                                               kegel.com
                                                              April 2003
.sp  2
.ce
Peer-to-Peer Communication over Middleboxes
.sp 2
.fi
.ne 4
Status of this Memo
.sp
.in 3
This document is an Internet-Draft and is subject to
all provisions of Section 10 of RFC2026.
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.  Note that
other groups may also distribute working documents as
Internet-Drafts.
.sp
Internet-Drafts are draft documents valid for a maximum of six
months and may be updated, replaced, or obsoleted by other
documents at any time.  It is inappropriate to use Internet-
Drafts as reference material or to cite them other than as
"work in progress."
.sp
The list of current Internet-Drafts can be accessed at
http://www.ietf.org/1id-abstracts.html
.sp
The list of Internet-Draft Shadow Directories can be accessed at
http://www.ietf.org/shadow.html
.sp
Distribution of this document is unlimited.
.sp
.in 0
.ne 4
Copyright Notice
.sp
.in 3
Copyright (C) The Internet Society (2003).  All Rights Reserved.

.sp
.in 0
.ne 4
Abstract
.sp
.in 3
This document describes methods
by which peer-to-peer (P2P) applications
can operate effectively
in the presence of commonly deployed middleboxes
such as firewalls and network address translators (NAT).
This document also provides recommendations
for the design of future middleboxes,
allowing them to support P2P applications more effectively
without compromising security or performance.
The focus of this document is on providing simple solutions
that can be deployed immediately,
without requiring the use of special proxy or relay protocols.
While not intending to preclude the use of such protocols,
our goal is to enable P2P applications
to function automatically
without specific knowledge of the middlebox(es) in the path,
thereby preserving the principle of transparency
inherent in the original design of these middleboxes
and increasing the overall robustness of the Internet.

.sp
.in 0
.ne 4
Table of Contents
.sp
.nf
   1.  Introduction .................................................
   2.  Middlebox Terminology ........................................
   3.  Techniques for P2P Communication over Middleboxes ............
       3.1.  Relaying ...............................................
       3.2.  Connection Reversal ....................................
       3.3.  UDP Hole Punching ......................................
             3.3.1.  Clients Behind Different NATs ..................
             3.3.2.  Clients Behind the Same NAT ....................
             3.3.3.  Twice NAT and Loopback Translation .............
             3.3.4.  Consistent Port Mappings .......................
       3.4.  UDP Port Number Prediction .............................
       3.5.  Simultaneous TCP Open ..................................
   4.  The Middlebox Traversal IP Option ............................
       4.1.  Option Format ..........................................
             4.1.1.  Source Check Field .............................
             4.1.2.  TCP P2P Port Field .............................
             4.1.3.  UDP P2P Port Field .............................
   5.  Application Design Guidelines ................................
   6.  NAT Design Guidelines ........................................
       6.1.  Maintaining Consistent Mappings for UDP Ports ..........
             6.1.1.  Preserving Port Numbers ........................
       6.2.  Maintaining Consistent Mappings for TCP Ports ..........
       6.3.  Proxy Protocols ........................................
   7.  Security Considerations ......................................
.fi

.sp
.in 0
.ne 4
1. Introduction
.sp
.in 3
The present-day Internet has seen the ubiquitous deployment
of "middleboxes" such as firewalls and network address translators (NAT),
driven primarily by security concerns
and the ongoing depletion of the IPv4 address space.
The asymmetric addressing and connectivity regimes
established by these middleboxes, however,
have created unique problems for peer-to-peer (P2P) applications and protocols,
such as teleconferencing and multiplayer on-line gaming.
These issues are likely to persist even into the IPv6 world,
where NAT is often used as an IPv4 compatibility mechanism [NAT-PT],
and firewalls will still be commonplace even after NAT is no longer required.
.sp
Currently deployed middleboxes are designed primarily
around the client/server paradigm,
in which relatively anonymous client machines
actively initiate connections to well-connected servers
having stable IP addresses and DNS names.
Most middleboxes implement an asymmetric security model
in which trusted hosts on the private internal network
can freely initiate outgoing connections
to untrusted hosts on the public network,
but external hosts cannot initiate connections to internal hosts
except as specifically configured by the middlebox's administrator.
In the common case of NAT,
a client on the internal network
often does not even have a unique IP address on the public Internet,
but instead must share a single public IP address, managed by the NAT,
with other hosts on the same private network.
The anonymity and inaccessibility of the internal hosts behind a middlebox
is not a problem for most client software such as web browsers,
which only need to initiate outgoing connections,
and this inaccessibility is often seen as a substantial security benefit.
.sp
In the peer-to-peer paradigm, however,
Internet hosts that would normally be considered to be "clients"
need to establish communication sessions directly with each other.
In this case, both the initiator and responder in a communication session
might lie behind different middleboxes,
neither endpoint having any permanent IP address
or other form of public network presence.
A common on-line gaming architecture, for example,
is for the participating application hosts
to contact a well-known server for initialization and administration purposes,
but then to establish direct connections with each other
for fast and efficient propagation of updates during gameplay.
Similarly, a file sharing application
might contact a well-known server for resource discovery or searching,
but establish direct connections with peer hosts for data transfer.
Middleboxes create problems for peer-to-peer connections
because hosts behind a middlebox
normally have no permanently usable public ports on the Internet
to which incoming TCP or UDP connections from other peers
can be directed.
RFC 3235 [NAT-APPL] briefly addresses this issue,
but does not offer any general solutions that do not compromise security.
.sp
In this document we address the P2P/middlebox problem in three ways.
First, we summarize known methods by which P2P applications
can work around the presence of middleboxes,
and provide a set of application design guidelines based on these practices
to make P2P applications operate more robustly
over currently-deployed middleboxes.
Second, we specify a new IP header option
with which P2P applications
can indicate their communication behavior and requirements
to future P2P-aware middleboxes,
making P2P connectivity more efficient and robust.
Finally, we provide design guidelines for future middleboxes
to allow them to support P2P applications more effectively.
without decreasing security or violating the middlebox's transparency.
Although we do not object to the development or use of
non-transparent proxy protocols for communication through middleboxes
[SOCKS, RSIP, MIDCOM, UPNP],
our focus here is purely on simpler transparency-preserving solutions.
.sp
.in 0
.ne 4
2. Middlebox Terminology
.sp
In this section we first summarize some important terms
relating to middlebox behavior.
We focus here on the two kinds of middleboxes
that commonly cause problems for P2P applications:
.sp
.in 3
Firewall:
.in 6
A firewall restricts communication between a private internal network
and the public Internet,
typically by dropping packets that are deemed "unauthorized."
A firewall generally examines but does not modify
the IP address and TCP/UDP port information in packets crossing the boundary.
.sp
.in 3
Network Address Translator (NAT):
.in 6
A network address translator not only examines but also modifies
the header information in packets flowing across the boundary,
allowing many hosts behind the NAT
to share the use of a smaller number of public IP addresses (often one).
.sp
.in 3
Network address translators in turn have two main varieties:
.sp
.in 3
Basic NAT:
.in 6
A Basic NAT maps an internal host's private IP address
to a temporary public IP address
without changing the TCP/UDP port numbers in packets crossing the boundary.
Basic NAT is generally only useful
when the NAT has a pool of public IP addresses
from which to make temporary mappings on behalf of internal hosts.
.sp
.in 3
Network Address/Port Translation (NAPT):
.in 6
By far the most common, a Network Address/Port Translator
examines and modifies both the IP address
and the TCP/UDP port number fields of packets crossing the boundary,
allowing multiple internal hosts
to share a single public IP address simultaneously.
.sp
.in 3
Refer to [NAT-TRAD] and [NAT-TERM] for more general information
on NAT taxonomy and terminology.
In order to describe techniques for P2P communication over NAT, however,
we must introduce some additional terms
for classifying the behavior of different types of NAT
as they affect peer-to-peer communication.
These terms are relatively new and do not appear in [NAT-TERM],
but have been used in more recent work [STUN, TURN, TEREDO].
.sp
When an internal host opens a new outgoing TCP or UDP session
through a network address/port translator,
the NAPT must assign to the session a public IP address and port number
so that subsequent response packets from the external endpoint
can be received by the NAT, translated,
and forwarded correctly to the internal host.
In the common case
in which the NAPT controls only one IP address on the external network,
the public IP address is always the NAPT's own IP address,
and the public port number is an arbitrary port
that the NAPT allocates to the new session.
In any case, the effect is that the NAPT establishes a mapping
between a (private IP address, private port number) pair
and a (public IP address, public port number) pair,
which defines the address translation the NAT will perform
for the duration of the session.
An issue of critical relevance to P2P applications
is how the NAT behaves
when an internal host initiates multiple simultanous sessions
from a single (private IP, private port) pair
to multiple distinct endpoints on the external network.
.sp
.in 3
Cone NAT:
.in 6
After establishing a mapping
from a (private IP, private port) pair to a (public IP, public port),
a cone NAT will re-use this same mapping
for any subsequent sessions the application may initiate
from the same private IP address and port number,
for as long as at least one session using the mapping remains active.
For example, suppose Client A in the diagram below
initiates two simultaneous outgoing sessions through a cone NAT,
from the same internal endpoint address (10.0.0.1:1234)
to two different external servers, S1 and S2.
The cone NAT assigns just one public endpoint address,
155.99.25.11:62000, to both of these sessions,
ensuring that the "identity" of the client's port
is maintained across address translation.
Cone NATs appear to be the most widely deployed in practice.
Since Basic NATs and non-NAT firewalls
do not modify port numbers at all as packets flow across the middlebox,
these types of middleboxes can be viewed
as a degenerate form of Cone NAT.
.sp
.KS
.nf
     Server S1                                     Server S2
  18.181.0.31:1235                              138.76.29.7:1235
         |                                             |
         |                                             |
         +----------------------+----------------------+
                                |
    ^  Session 1 (A-S1)  ^      |      ^  Session 2 (A-S2)  ^
    |  18.181.0.31:1235  |      |      |  138.76.29.7:1235  |
    v 155.99.25.11:62000 v      |      v 155.99.25.11:62000 v
                                |
                             Cone NAT
                           155.99.25.11
                                |
    ^  Session 1 (A-S1)  ^      |      ^  Session 2 (A-S2)  ^
    |  18.181.0.31:1235  |      |      |  138.76.29.7:1235  |
    v   10.0.0.1:1234    v      |      v   10.0.0.1:1234    v
                                |
                             Client A
                          10.0.0.1:1234
.fi
.KE
.sp
.in 3
Symmetric NAT:
.in 6
A symmetric NAT, in contrast,
does not maintain a consistent mapping from (private IP, private port)
to (public IP, public port) across all sessions,
but instead assigns a new public port to each new session.
For example,
suppose Client A initiates two outgoing sessions from the same port as above,
one with S1 and one with S2.
A symmetric NAT might allocate
the public endpoint address 155.99.25.11:62000 to session 1,
and then allocate a different public endpoint address,
155.99.25.11:62001, when the application initiates session 2.
The NAT can still differentiate between the two sessions
for translation purposes
because the external endpoint addresses involved in the sessions
(those of S1 and S2) differ,
but the "identity" of the client application's single endpoint address
has been lost across the address translation boundary.
.sp
.KS
.nf
     Server S1                                     Server S2
  18.181.0.31:1235                              138.76.29.7:1235
         |                                             |
         |                                             |
         +----------------------+----------------------+
                                |
    ^  Session 1 (A-S1)  ^      |      ^  Session 2 (A-S2)  ^
    |  18.181.0.31:1235  |      |      |  138.76.29.7:1235  |
    v 155.99.25.11:62000 v      |      v 155.99.25.11:62001 v
                                |
                           Symmetric NAT
                           155.99.25.11
                                |
    ^  Session 1 (A-S1)  ^      |      ^  Session 2 (A-S2)  ^
    |  18.181.0.31:1235  |      |      |  138.76.29.7:1235  |
    v   10.0.0.1:1234    v      |      v   10.0.0.1:1234    v
                                |
                             Client A
                          10.0.0.1:1234
.fi
.KE
.sp
.in 3
The issue of cone versus symmetric NAT behavior
applies equally and independently to TCP and UDP traffic.
For example, a NAT might behave in symmetric fashion
when translating outgoing TCP connections,
while behaving in cone fashion for UDP sessions initiated by internal hosts.
.sp
Cone NAT is further classified
according to how liberally the NAT accepts incoming traffic
directed to an already-established (public IP, public port) pair.
This classification generally applies only to UDP traffic,
since NATs and firewalls usually reject
all incoming TCP connection attempts unconditionally
unless specifically configured to do otherwise.
.sp
.in 3
Full Cone NAT:
.in 6
After establishing a public/private mapping
for a new outgoing session,
a full cone NAT will subsequently accept incoming traffic
to the corresponding public port
from ANY external endpoint on the public network.
Full cone NAT is also sometimes called "promiscuous" NAT,
and is becoming less common because its promiscuous behavior
is usually seen as a security weakness.
.sp
.in 3
Restricted Cone NAT:
.in 6
A restricted cone NAT only forwards
an incoming packet directed to a public port
if its external (source) IP address matches the address of a node
to which the internal host has previously sent one or more outgoing packets
through this mapping.
A restricted cone NAT effectively refines
the firewall principle of rejecting unsolicited incoming traffic,
by restricting incoming traffic through a mapping
to a set of "known" external IP addresses.
.sp
.in 3
Port-Restricted Cone NAT:
.in 6
A port-restricted cone NAT, in turn,
only forwards an incoming packet
if its external IP address AND port number
match those of an external endpoint
to which the internal host has previously sent outgoing packets
through this mapping.
A port-restricted cone NAT provides internal nodes
the same level of protection against unsolicited incoming traffic
that a symmetric NAT does,
while maintaining a private port's identity across translation.
.sp
.in 3
Finally, in this document we define three new terms
for classifying the P2P-relevant behavior of middleboxes:
.sp
.in 3
P2P-Middlebox:
.in 6
A P2P-Middlebox is middlebox that provides NAT and/or firewall functionality,
and is designed to be friendly to P2P applications
as specified in this document.
At minimum, a P2P-Middlebox must implement Cone NAT behavior for UDP traffic,
allowing applications to establish robust P2P connectivity
using the UDP hole punching technique described later.
Ideally, a P2P-Middlebox should also understand the Middlebox Traversal Option
and allow applications to make P2P connections via both TCP and UDP.
.sp
.in 3
P2P-firewall:
.in 6
A P2P-firewall is a P2P-Middlebox that provides firewall functionality
but performs no address translation.
.sp
.in 3
P2P-NAT:
.in 6
A P2P-NAT is a P2P-Middlebox that provides NAT functionality,
and may also provide firewall functionality.
.sp
.in 0
.ne 4
3. Techniques for P2P Communication over Middleboxes
.sp
.in 3
This section reviews in detail the currently known techniques
for implementing peer-to-peer communication over existing middleboxes,
from the perspective of the application or protocol designer.
.sp
.in 0
.ne 4
3.1. Relaying
.sp
.in 3
The most reliable, but least efficient,
method of implementing peer-to-peer communication
in the presence of a middlebox
is to make the peer-to-peer communication
look to the network like client/server communication through relaying.
For example, suppose two client hosts, A and B,
have each initiated TCP or UDP connections
with a well-known server S having a permanent IP address.
The clients reside on separate private networks, however,
and their respective middleboxes prevent either client
from directly initiating a connection to the other.
.sp
.KS
.nf
                             Server S
                                |
                                |
         +----------------------+----------------------+
         |                                             |
       NAT A                                         NAT B
         |                                             |
         |                                             |
      Client A                                      Client B
.fi
.KE
.sp
Instead of attempting a direct connection,
the two clients can simply use the server S
to relay messages between them.
For example, to send a message to client B,
client A simply sends the message to server S
along its already-established client/server connection,
and server S then sends the message on to client B
using its existing client/server connection with B.
.sp
This method has the advantage that it will always work
as long as both clients have connectivity to the server.
Its obvious disadvantages are that
it consumes the server's processing power and network bandwidth unnecessarily,
and communication latency between the two clients is likely to be increased
even if the server is well-connected.
The TURN protocol [TURN] defines a method of implementing relaying
in a relatively secure fashion.
.sp
.in 0
.ne 4	
3.2. Connection Reversal
.sp
.in 3
The second technique works if only one of the clients is behind a middlebox.
For example, suppose client A is behind a NAT
but client B has a globally routable IP address,
as in the following diagram:
.sp
.KS
.nf
                             Server S
                         18.181.0.31:1235
                                |
                                |
         +----------------------+----------------------+
         |                                             |
       NAT A                                           |
 155.99.25.11:62000                                    |
         |                                             |
         |                                             |
      Client A                                      Client B
   10.0.0.1:1234                               138.76.29.7:1234
.fi
.KE
.sp
Client A has private IP address 10.0.0.1,
and the application is using TCP port 1234.
This client has established a connection with server S
at public IP address 18.181.0.31 and port 1235.
NAT A has assigned TCP port 62000,
at its own public IP address 155.99.25.11,
to serve as the temporary public endpoint address
for A's session with S:
therefore, server S believes that client A is
at IP address 155.99.25.11 using port 62000.
Client B, however, has its own permanent IP address, 138.76.29.7,
and the peer-to-peer application on B
is accepting TCP connections at port 1234.
.sp
Now suppose client B would like
to initiate a peer-to-peer communication session with client A.
B might first attempt to contact client A
either at the address client A believes itself to have,
namely 10.0.0.1:1234,
or at the address of A as observed by server S,
namely 155.99.25.11:62000.
In either case, however, the connection will fail.
In the first case, traffic directed to IP address 10.0.0.1
will simply be dropped by the network
because 10.0.0.1 is not a publicly routable IP address.
In the second case, the TCP SYN request from B
will arrive at NAT A directed to port 62000,
but NAT A will reject the connection request
because only outgoing connections are allowed.
.sp
After attempting and failing to establish a direct connection to A,
client B can use server S to relay a request to client A
to initiate a "reversed" connection to client B.
Client A, upon receiving this relayed request through S,
opens a TCP connection to client B
at B's public IP address and port number.
NAT A allows the connection to proceed
because it is originating inside the firewall,
and client B can receive the connection
because it is not behind a middlebox.
.sp
A variety of current peer-to-peer systems implement this technique.
Its main limitation, of course, is that it only works
as long as only one of the communicating peers is behind a NAT:
in the increasingly common case where peers are behind NATs,
the method fails.
Because connection reversal is not a general solution to the problem,
it is NOT recommended as a primary strategy.
Applications may choose to attempt connection reversal,
but should be able to fall back automatically
on another mechanism such as relaying
if neither a "forward" nor a "reverse" connection can be established.
.sp
.in 0
.ne 4	
3.3. UDP Hole Punching
.sp
.in 3
The third technique,
and the one of primary interest in this document,
is widely known as "UDP Hole Punching."
UDP hole punching relies on the properties of common firewalls and cone NATs
to allow appropriately designed peer-to-peer applications to "punch holes"
through the firewall and establish direct connectivity with each other,
even when both communicating hosts may lie behind middleboxes.
This technique was mentioned briefly in section 5.1 of RFC 3027 [NAT-PROT],
and has been informally described elsewhere on the Internet [KEGEL]
and used in some recent protocols [TEREDO, ICE].
As the name implies, unfortunately,
this technique works reliably only with UDP.
.sp
We will consider two specific scenarios,
and how applications can be designed to handle both of them gracefully.
In the first situation, representing the common case,
two clients desiring direct peer-to-peer communication
reside behind two different NATs.
In the second, the two clients actually reside behind the same NAT,
but do not necessarily know that they do.
.sp
.in 0
.ne 4	
3.3.1. Clients Behind Different NATs
.sp
.in 3
Suppose clients A and B both have private IP addresses
and lie behind different network address translators.
The peer-to-peer application running on clients A and B
and on server S each use UDP port 1234.
A and B have each initiated UDP communication sessions with server S,
causing NAT A to assign its own public UDP port 62000
for A's session with S,
and causing NAT B to assign its port 31000 to B's session with S,
respectively.
.sp
.KS
.nf
                             Server S
                         18.181.0.31:1234
                                |
                                |
         +----------------------+----------------------+
         |                                             |
       NAT A                                         NAT B
 155.99.25.11:62000                            138.76.29.7:31000
         |                                             |
         |                                             |
      Client A                                      Client B
   10.0.0.1:1234                                 10.1.1.3:1234
.fi
.KE
.sp
Now suppose that client A wants to establish a UDP communication session
directly with client B.
If A simply starts sending UDP messages to B's public address,
138.76.29.7:31000,
then NAT B will typically discard these incoming messages
(unless it is a full cone NAT),
because the source address and port number
does not match those of S,
with which the original outgoing session was established.
Similarly, if B simply starts sending UDP messages to A's public address,
then NAT A will typically discard these messages.
.sp
Suppose A starts sending UDP messages to B's public address, however,
and simultaneously relays a request through server S to B,
asking B to start sending UDP messages to A's public address.
A's outgoing messages directed to B's public address (138.76.29.7:31000)
cause NAT A to open up a new communication session
between A's private address and B's public address.
At the same time, B's messages to A's public address (155.99.25.11:62000)
cause NAT B to open up a new communication session
between B's private address and A's public address.
Once the new UDP sessions have been opened up in each direction,
client A and B can communicate with each other directly
without further burden on the "introduction" server S.
.sp
The UDP hole punching technique has several useful properties.
Once a direct peer-to-peer UDP connection
has been established between two clients behind middleboxes,
either party on that connection can in turn take over the role of "introducer"
and help the other party establish peer-to-peer connections
with additional peers,
minimizing the load on the initial introduction server S.
The application does not need to attempt to detect explicitly
what kind of middlebox it is behind, if any [STUN],
since the procedure above will establish peer-to-peer communication channels
equally well if either or both clients do not happen to be behind a middlebox.
The hole punching technique even works automatically under "Twice NAT",
where one or both clients are removed from the public Internet
via two or more levels of address translation.
.sp
.in 0
.ne 4	
3.3.2. Clients Behind the Same NAT
.sp
.in 3
Now consider the scenario
in which the two clients (probably unknowingly)
happen to reside behind the same NAT,
and are therefore located in the same private IP address space.
Client A has established a UDP session with server S,
to which the common NAT has assigned public port number 62000.
Client B has similarly established a session with S,
to which the NAT has assigned public port number 62001.
.sp
.KS
.nf
                             Server S
                         18.181.0.31:1234
                                |
                                |
                               NAT
                      A-S 155.99.25.11:62000
                      B-S 155.99.25.11:62001
                                |
         +----------------------+----------------------+
         |                                             |
      Client A                                      Client B
   10.0.0.1:1234                                 10.1.1.3:1234
.fi
.KE
.sp
Suppose that A and B use the UDP hole punching technique as outlined above
to establish a communication channel using server S as an introducer.
Then A and B will learn each other's public IP addresses and port numbers
as observed by server S,
and start sending each other messages at those public addresses.
The two clients will be able to communicate with each other this way
as long as the NAT allows hosts on the internal network
to open translated UDP sessions with other internal hosts
and not just with external hosts.
We refer to this situation as "loopback translation,"
because packets arriving at the NAT from the private network
are translated and then "looped back" to the private network
rather than being passed through to the public network.
For example, when A sends a UDP packet to B's public address,
the packet initially has
a source IP address and port number of 10.0.0.1:124
and a destination of 155.99.25.11:62001.
The NAT receives this packet,
translates it to have a source of 155.99.25.11:62000 (A's public address)
and a destination of 10.1.1.3:1234,
and then forwards it on to B.
Even if loopback translation is supported by the NAT,
this translation and forwarding step is obviously unnecessary in this situation,
and is likely to add latency to the dialog between A and B
as well as burdening the NAT.
.sp
The solution to this problem is straightforward, however.
When A and B initially exchange address information through server S,
they should include their own IP addresses and port numbers
as "observed" by themselves,
as well as their addresses as observed by S.
The clients then simultaneously start sending packets to each other
at each of the alternative addresses they know about,
and use the first address that leads to successful communication.
If the two clients are behind the same NAT,
then the packets directed to their private addresses
are likely to arrive first,
resulting in a direct communication channel not involving the NAT.
If the two clients are behind different NATs,
then the packets directed to their private addresses
will fail to reach each other at all,
but the clients will hopefully establish connectivity
using their respective public addresses.
It is important that these packets be authenticated in some way, however,
since in the case of different NATs it is entirely possible
for A's messages directed at B's private address
to reach some other, unrelated node on A's private network,
or vice versa.
.sp
.in 0
.ne 4	
3.3.3. Twice NAT and Loopback Translation
.sp
.in 3
In some topologies involving multiple levels of NAT,
it is not possible for two clients
to establish an "optimal" P2P route between them
without specific knowledge of the topology.
Consider for example the following situation:
.sp
.KS
.nf
                             Server S
                         18.181.0.31:1234
                                |
                                |
                              NAT X
                      A-S 155.99.25.11:62000
                      B-S 155.99.25.11:62001
                                |
                                |
         +----------------------+----------------------+
         |                                             |
       NAT A                                         NAT B
 192.168.1.1:30000                             192.168.1.2:31000
         |                                             |
         |                                             |
      Client A                                      Client B
   10.0.0.1:1234                                 10.1.1.3:1234
.fi
.KE
.sp
Suppose NAT X is a large industrial NAT
deployed by an internet service provider (ISP)
to multiplex many customers onto a few public IP addresses,
and NATs A and B are small consumer NAT gateways
deployed independently by two of the ISP's customers
to multiplex their private home networks
onto their respective ISP-provided IP addresses.
Only server S and NAT X have globally routable IP addresses;
the "public" IP addresses used by NAT A and NAT B
are actually private to the ISP's addressing realm,
while client A's and B's addresses in turn
are private to the addressing realms of NAT A and B, respectively.
Each client initiates an outgoing connection to server S as before,
causing NATs A and B each to create a single public/private translation,
and causing NAT X to establish a public/private translation for each session.
.sp
Now suppose clients A and B attempt to establish
a direct peer-to-peer UDP connection.
The optimal method would be for client A
to send messages to client B's public address at NAT B,
192.168.1.2:31000 in the ISP's addressing realm,
and for client B to send messages to A's public address at NAT B,
namely 192.168.1.1:30000.
Unfortunately, A and B have no way to learn these addresses,
because server S only sees the "global" public addresses of the clients,
155.99.25.11:62000 and 155.99.25.11:62001.
Even if A and B had some way to learn these addresses,
there is still no guarantee that they would be usable
because the address assignments in the ISP's private addressing realm
might conflict with unrelated address assignments
in the clients' private realms.
The clients therefore have no choice
but to use their global public addresses as seen by S
for their P2P communication,
and rely on NAT X to provide loopback translation.
.sp
.in 0
.ne 4	
3.3.4. Consistent Port Mappings
.sp
.in 3
The hole punching technique has one main caveat:
it works only if both NATs are cone NATs (or non-NAT firewalls),
which maintain a consistent mapping
from a given (private IP, private UDP) pair
to a translated (public IP, public UDP) pair
for as long as that UDP port is in use.
Assigning a new public port for each new session,
as a symmetric NAT does,
makes it impossible for a UDP application
to reuse an already-established translation
for communication with different external destinations.
Since cone NATs are the most widespread,
the UDP hole punching technique is fairly broadly applicable;
nevertheless a substantial fraction of deployed NATs are symmetric
and do not support the technique.
.sp
Since UDP hole punching is the most efficient existing method
of establishing direct peer-to-peer communication
between two nodes that are both behind NATs,
and it works with a wide variety of existing NATs,
it is recommended that applications use this technique
if efficient peer-to-peer communication is required,
but be prepared to fall back on simple relaying
when direct communication cannot be established.
XXX move this to application guidelines?
.sp
.in 0
.ne 4
3.4. UDP Port Number Prediction
.sp
.in 3
A variant of the UDP hole punching technique discussed above exists
that allows peer-to-peer UDP sessions to be created
in the presence of some symmetric NATs.
This method is
sometimes called the "N+1" technique [BIDIR]
and is explored in detail by Takeda [SYM-STUN].
The method works by analyzing the behavior of the NAT
and attempting to predict
the public port numbers it will assign to future sessions.
Consider again the situation in which two clients, A and B,
each behind a separate NAT, have each established UDP connections
with a permanently addressable server S:
.sp
.KS
.nf
                               Server S
                           18.181.0.31:1234
                                  |
                                  |
           +----------------------+----------------------+
           |                                             |
    Symmetric NAT A                               Symmetric NAT B
A-S 155.99.25.11:62000                        B-S 138.76.29.7:31000
           |                                             |
           |                                             |
        Client A                                      Client B
     10.0.0.1:1234                                 10.1.1.3:1234
.fi
.KE
.sp
NAT A has assigned its own UDP port 62000
to the communication session between A and S,
and NAT B has assigned its port 31000
to the session between B and S.
By communicating through server S,
A and B learn each other's public IP addresses and port numbers
as observed by S.
Client A now starts sending UDP messages
to port 31001 at address 138.76.29.7
(note the port number increment),
and client B simultaneously starts sending messages
to port 62001 at address 155.99.25.11.
If NATs A and B assign port numbers to new sessions sequentially,
and if not much time has passed
since the A-S and B-S sessions were initiated,
then a working bidirectional communication channel
between A and B should result.
A's messages to B cause NAT A to open up a new session,
to which NAT A will (hopefully) assign public port number 62001,
because 62001 is next in sequence after the port number 62000
it previously assigned to the session between A and S.
Similarly, B's messages to A will cause NAT B to open a new session,
to which it will (hopefully) assign port number 31001.
If both clients have correctly guessed
the port numbers each NAT assigns to the new sessions,
then a bidirectional UDP communication channel
will have been established as shown below.
.sp
.KS
.nf
                               Server S
                           18.181.0.31:1234
                                  |
                                  |
           +----------------------+----------------------+
           |                                             |
         NAT A                                         NAT B
A-S 155.99.25.11:62000                        B-S 138.76.29.7:31000
A-B 155.99.25.11:62001                        B-A 138.76.29.7:31001
           |                                             |
           |                                             |
        Client A                                      Client B
     10.0.0.1:1234                                 10.1.1.3:1234
.fi
.KE
.sp
Obviously there are many things that can cause this trick to fail.
If the predicted port number at either NAT
already happens to be in use by an unrelated session,
then the NAT will skip over that port number
and the connection attempt will fail.
If either NAT sometimes or always chooses port numbers non-sequentially,
then the trick will fail.
If a different client behind NAT A (or B respectively) opens up
a new outgoing UDP connection to any external destination
after A (B) establishes its connection with S
but before sending its first message to B (A),
then the unrelated client will inadvertently "steal" the desired port number.
This trick is therefore much less likely to work
when either NAT involved is under load.
.sp
Since in practice a P2P application implementing this trick
would still need to work if the NATs are cone NATs,
or if one is a cone NAT and the other is a symmetric NAT,
the application would need to detect beforehand
what kind of NAT is involved on either end [STUN]
and modify its behavior accordingly,
increasing the complexity of the algorithm
and the general brittleness of the network.
Finally, port number prediction has no chance of working
if either client is behind two or more levels of NAT
and the NAT(s) closest to the client are symmetric.
For all of these reasons,
it is NOT recommended that new applications implement this trick;
it is mentioned here for historical and informational purposes.
.sp
.in 0
.ne 4
3.5. Simultaneous TCP Open
.sp
.in 3
There is a method that can be used in some cases
to establish direct peer-to-peer TCP connections
between a pair of nodes that are both behind existing middleboxes.
Most TCP sessions start with one endpoint sending a SYN packet,
to which the other party responds with a SYN-ACK packet.
It is possible and legal, however, for two endpoints to start a TCP session
by simultaneously sending each other SYN packets,
to which each party subsequently responds with a separate ACK.
This procedure is known as a "simultaneous open."
.sp
If a middlebox receives a TCP SYN packet from outside the private network
attempting to initiate an incoming TCP connection,
the middlebox will normally reject the connection attempt
by either dropping the SYN packet
or sending back a TCP RST (connection reset) packet.
If, however, the SYN packet arrives
with source and destination addresses and port numbers
that correspond to a TCP session that the middlebox believes is already active,
then the middlebox will allow the packet to pass through.
In particular, if the middlebox has just recently seen and transmitted
an outgoing SYN packet with the same addresses and port numbers,
then it will consider the session active and allow the incoming SYN through.
If clients A and B can each correctly predict
the public port number that its respective middlebox
will assign the next outgoing TCP connection,
and if each client initiates
an outgoing TCP connection with the other client
timed so that each client's outgoing SYN passes through its local middlebox
before either SYN reaches the opposite middlebox,
then a working peer-to-peer TCP connection will result.
.sp
Unfortunately, this trick may be even more fragile and timing-sensitive
than the UDP port number prediction trick described above.
First, unless both middleboxes are simple firewalls
or implement cone NAT behavior on their TCP traffic,
all the same things can go wrong
with each side's attempt to predict the public port numbers
that the respective NATs will assign to the new sessions.
In addition,
if either client's SYN arrives at the opposite middlebox too quickly,
then the remote middlebox may reject the SYN with a RST packet,
causing the local middlebox in turn to close the new session
and make future SYN retransmission attempts
using the same port numbers futile.
Finally, even though support for simultaneous open
is technically a mandatory part of the TCP specification [TCP],
it is not implemented correctly in some common operating systems.
For this reason,
this trick is likewise mentioned here only for historical reasons;
it is NOT recommended for use by applications.
Applications that require efficient, direct peer-to-peer communication
over existing NATs should use UDP.
.sp
.in 0
.ne 4
4. The Middlebox Traversal IP Option
.sp
.in 3
Most middleboxes,
particularly consumer-level NATs deployed by home users,
are not intended to constrain applications running on the private network,
but to provide IP address sharing and protect against outside attackers.
The fact that these middleboxes do constrain or break internal applications
is a side-effect of their inability to distinguish
between legitimate traffic initiated internally
and unsolicited traffic initiated externally,
particularly when applications exhibit peer-to-peer communication patterns.
This problem in turn stems from the fact that
the network and transport layers provide no application-independent information
about the communication behavior of higher-level protocols and applications
that the middlebox might use to make this distinction reliably.
This section defines a new IP option, the "Middlebox Traversal option",
which applications can use to provide this information
to middleboxes that may exist on their communication paths.
The use of this option by applications,
and its correct interpretation by middleboxes,
should allow the latter to perform their functions
more reliably and transparently across a wider variety of applications.
The option does not require applications or middleboxes
to implement any complex new protocols,
it works even when there are two or more middleboxes on a communication path,
and if widely deployed will enable reliable peer-to-peer communication
for TCP as well as UDP traffic.
.sp
A P2P application uses the middlebox traversal option
by including it in one or more outgoing packets passing through a middlebox,
typically in packets comprising a "control connection"
to some well-connected server on the public Internet.
If the P2P application communicates with several well-connected servers,
or if it does not know which of a set of peers are well-connected
and which are local to some internal private network,
the application can merely include the middlebox traversal option
in all outgoing packets it transmits.
The application may not know specifically if
or what kind of middleboxes are present on a given path,
but if middleboxes are present and support the option,
they can modify their behavior appropriately
to support the application's P2P communication needs more effectively
without compromising overall security.
.sp
.sp
.in 0
.ne 4
4.1. Option Format
.sp
.in 3
The Middlebox Traversal option is defined for both IPv4 and IPv6 packets
carrying either TCP or UDP transport-level payloads.
A middlebox traversal option contained in a TCP control packet
may request UDP-based P2P port bindings, and vice versa.
When the option is included in an IPv6 control packet,
it must be located in the Destination Options Header.
The option must be aligned on a 2-byte boundary
within the IP header,
by inserting a single-byte "no-op" option beforehand if necessary.
The middlebox traversal option has the following format:
.sp
.KS
.nf
UDP Middlebox Traversal Option, IPv4 Header:
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0   -TBD-  |    Length     |         Source Check          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         TCP P2P Port          |         UDP P2P Port          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    Type = TBD

UDP Middlebox Traversal Option, IPv6 Header:
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0   -TBD-  |  Data-Length  |         Source Check          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         TCP P2P Port          |         UDP P2P Port          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    Type = TBD
.fi
.KE
.sp
The Length field in the IPv4 option must be at least 8,
and the Data-Length field in the IPv6 option must be at least 6.
Additional octets may be present in the option
after the Source Check, TCP P2P Port, and UDP P2P Port fields defined above,
but any such additional octets are reserved for future specification.
Senders should include only the first six data octets as shown above,
and receivers should ignore any additional data octets.
.sp
.in 0
.ne 4
4.1.1. Source Check Field
.sp
.in 3
The Source Check field is a 16-bit one's complement checksum,
computed the same way as the IPv4 header checksum,
of the following pseudo-header
constructed from other parts of the packet:
.sp
.KS
.nf
Source Check Pseudo-Header, IPv4
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Source IP Address                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      Source TCP/UDP Port      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    Length = 6 octets

Source Check Pseudo-Header, IPv6
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                       Source IP Address                       +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      Source TCP/UDP Port      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    Length = 18 octets
.fi
.KE
.sp
The Source Check field allows the receiver of a packet containing this option
to determine whether or not any NATs this packet has traversed
have handled the option correctly.
On examining a packet containing a middlebox traversal option,
a receiver should first verify the Source Check field
against the packet's source IP address and source TCP/UDP port number,
and ignore the option if there is a mismatch.
On forwarding a packet containing a middlebox traversal option
with a valid Source Check field,
a NAT that supports the option
MUST re-compute or adjust the Source Check field appropriately
to match the packet's new source address and port number after translation.
.sp
.in 0
.ne 4
4.1.2. TCP P2P Port Field
.sp
.in 3
The TCP P2P Port field indicates
the TCP port number on the sending host
that the application is using
to listen for incoming TCP-based P2P connections.
This field may be zero
to indicate that the application does not use a TCP-based P2P port.
If the control packet containing this IP option is a TCP packet,
then the TCP P2P Port field may or may not match
the source port number in the packet's TCP header.
Since most operating systems do not allow an application
to initiate an outgoing connection
and simultaneously accept incoming connections on the same port,
P2P applications will typically need to specify a TCP P2P Port
different from the source port of the control connection.
A UDP-based control packet may also contain a middlebox traversal option
specifying a non-zero TCP P2P Port, however.
.sp
A firewall that supports the middlebox traversal option
should open up a temporary hole in the firewall for this TCP port,
subsequently allowing unrestricted incoming TCP connections
directed to that port.
This hole should remain active for at least one minute
after either:
.sp
.in 6
(a) the firewall observes ANY outgoing TCP or UDP packet
containing a middlebox option
specifying the same TCP P2P Port.
.sp
(b) the firewall observes ANY outgoing TCP traffic
whose source TCP port matches the specified TCP P2P Port.
.sp
.in 3
The firewall MAY track individual TCP connections
initiated through the resulting hole,
whether incoming or outgoing,
and keep the firewall hole open until all connections are closed
regardless of the presence of activity.
Since firewalls are not required
to track individual TCP-based P2P connections, however,
P2P applications should use suitable keepalive traffic
on their control and/or data connections
to ensure that their firewall holes remain active.
.sp
A NAT that supports the middlebox traversal option
acts the same way as described above for a firewall,
but instead of merely opening up a hole for incoming traffic,
the NAT also allocates a public TCP port number
at an IP address it controls
and establishes a private/public translation as necessary.
When forwarding the control packet containing the middlebox traversal option,
the NAT MUST translate the TCP P2P Port field in the option
in exactly the same way as it would translate the Source Port field
of a TCP packet originating from that port,
replacing the private TCP port number specified by the application
with the public TCP port number assigned by the NAT.
Translating the TCP P2P Port field in this way
ensures that the option remains valid even if the packet
traverses multiple NATs that all support the option,
and allows the eventual receiver of the control packet
to determine the (final) translated TCP port number
corresponding to the sender's TCP-based P2P port.
.sp
If a middlebox supports the middlebox traversal option
but cannot establish a TCP-based P2P port binding for any reason,
for example because it only supports UDP-based P2P traffic,
then the middlebox MUST set the TCP P2P Port field to zero
before forwarding the control packet.
.sp
4.1.3. UDP P2P Port Field
.sp
.in 3
The UDP P2P Port field indicates
the UDP port number that the sending application is using
to send and receive UDP-based P2P traffic.
This field may be zero
to indicate that the application does not use a UDP-based P2P port.
If the control packet containing this IP option is a UDP packet,
then the UDP P2P Port field may or may not match
the source port number in the packet's UDP header.
A TCP-based control packet may also contain a middlebox traversal option
specifying a non-zero UDP P2P Port, however.
.sp
In response to a non-zero UDP P2P Port field,
a firewall that supports the option
should open up a temporary hole in the firewall for the specified UDP port,
subsequently allowing unrestricted incoming traffic to that UDP port
from any external endpoint.
The hole should be associated with an inactivity timer
lasting at least one minute,
which is reset either by another outoing (TCP or UDP) control packet
containing a middlebox traversal option with the same UDP P2P Port field,
or by an ougoing UDP packet from the specified port.
The firewall MUST NOT associate separate inactivity timers
with each individual UDP session through this port,
even if the firewall does so for normal outgoing UDP sessions
not established using the middlebox traversal option.
Since UDP does not provide middleboxes
with the information necessary to track
the lifetimes of individual connections,
the firewall must use the inactivity timer alone
to determine when it can close the hole.
.sp
As with TCP, a NAT that supports the midlebox traversal option
should create a new UDP-based translation for the specified port
if none already exists,
translate the UDP P2P Port number field in the option
as if it was the Source Port in an outgoing UDP packet,
and subsequently translate and forward all incoming UDP traffic
directed to the NAT-assigned public UDP port
regardless of its external origin.
The translation established by this mechanism
must persist using an inactivity timer
with a period of at least one minute,
as discussed above for firewalls.
.sp
If a middlebox supports the middlebox traversal option
but cannot establish a UDP-based P2P port binding for any reason,
then the middlebox MUST set the UDP P2P Port field to zero
before forwarding the control packet.
.sp
.in 0
.ne 4
5. Application Design Guidelines
.sp
.in 3
.sp
.in 0
.ne 4
6. NAT Design Guidelines
.sp
.in 3
This section discusses considerations
for the design of network address translators,
as they affect peer-to-peer applications.

XXX require and add section on loopback translation




A NAT or firewall must have a way
to determine when a communication session is no longer in use
so that it can free its address translation or filtering resources
for other purposes.
For TCP connections,
the usual method is to track the TCP state machine for each session,
freeing the NAT/firewall state after the TCP connection
has been observed to be closed or reset.
For connectionless UDP traffic, however,
the only general-purpose method available is to employ an activity timer.
For one-to-one traffic in mode 00,
a P2P-NAT or P2P-firewall should treat every UDP session independently
for purposes of determining its lifetime.
In other words, if a client establishes two outgoing mode 00 sessions
originating from a single internal UDP endpoint,
an intermediary should maintain a separate activity timer for each session,
and close each session independently when its timeout expires.
For the other three modes, however,
a P2P-NAT or P2P-firewall should associate the UDP activity timer
with transport endpoints rather than with individual sessions.
For example,
after an application opens an outgoing session in mode 11
from a given (private IP, private port)
to establish a peer-to-peer mapping allowing incoming connections,
ANY subsequent mode 11 traffic between that private endpoint
and any external entity
should cause intermediaries to reset their timers for that private endpoint.
This behavior allows peer-to-peer applications
that communicate sporadically with many remote nodes
to maintain connectivity without requiring
an excessive amount of keepalive traffic.
In any case, all UDP activity timeouts MUST be at least thirty seconds.
.sp
A P2P-NAT may use any method
of allocating and assigning (public IP, public port) pairs to sessions
as long as the allocation rules satisfy the semantics
for the appropriate communication mode as defined above.
For example,
a P2P-NAT may assign a single (public IP, public port) pair
to several unrelated one-to-one (mode 00) sessions at once
originating at different (private IP, private port) endpoints,
as long as these sessions can still be distinguished
by their (external IP, external port) pair.
A given (public IP, public port) pair cannot, however,
be shared between multiple unrelated sessions
if any of those sessions involves a mode 01, 10, or 11 mapping.
An easy way for a P2P-NAT to implement this behavior
is to divide its assignable port namespace statically,
reserving some of its ports for one-to-one sessions
and a different set of ports for one-to-many sessions.
.sp
XXX
> > Further, the simply P2P-NAT may also be configured with applications
> > that need the P2P feature, so they can automagically pick the
> > required P2P ports from the right port block.
.sp



.sp
.in 0
.ne 4
6.1. Maintaining Consistent Public/Private Mappings for UDP Ports
.sp
.in 3
The primary and most important recommendation of this document
for NAT designers
is that the NAT maintain a consistent and stable mapping
between a given (internal IP address, internal UDP port) pair
and a corresponding (public IP address, public UDP port) pair
for as long as any active sessions exist using that mapping.
The NAT may filter incoming traffic on a per-session basis,
by examining both the source and destination IP addresses and port numbers
in each packet.
When a node on the private network
starts sending outgoing packets to a new external destination, however,
while using the same source IP address and UDP port
as an existing translated UDP session,
the NAT should ensure that the new UDP session
is given the same public IP address and UDP port numbers
as the existing session.
.sp
One method of implementing this behavior,
meant to be only illustrative and not prescriptive,
is outlined here.
The "critical-path" processing performed by a NAT
on a packet flowing in either direction
typically involves
extracting the source and destination IP addresses from the IP header,
and the source and destination TCP/UDP port numbers from the TCP/UDP header,
and using these four values to index into a table of active sessions.
When a packet is received for which no entry is found in the session table,
the NAT must decide whether or not and how to establish a new session,
and this is where the typical "outgoing sessions only" firewall policy
comes into effect.
.sp
If the unknown packet was received from the public network,
then it is usually dropped
(or perhaps rejected with a RST in the case of TCP).
If a UDP packet for an unknown session
arrives from the private network, however,
and the NAT is configured in the typical way to allow outgoing UDP sessions,
the then NAT looks up the packet's (source IP address, source UDP port)
in a second internal table: a "mapping table."
For a given (private IP address, private UDP port) on the internal network,
the NAT stores in the mapping table
the corresponding (public IP address, public UDP port)
it has assigned to represent that private endpoint.
If a mapping already exists,
the NAT simply uses the existing mapping when constructing the new session.
If no such entry is present in the mapping table,
then the NAT allocates a new public UDP port from its pool
and creates a new mapping table entry along with the new session.
The NAT also maintains with each entry in the mapping table
a list or count of the active sessions using that mapping,
so that it can reassign the public UDP port to other purposes
once all of the outstanding sessions for the mapping are deemed inactive.
.sp
.in 0
.ne 4
6.1.1. Preserving Port Numbers
.sp
.in 3
Some NATs, when establishing a new UDP session,
attempt to assign the same public port number
as the corresponding private port number,
if that port number happens to be available.
For example, if client A at address 10.0.0.1
initiates an outgoing UDP session with a datagram from port number 1234,
and the NAT's public port number 1234 happens to be available,
then the NAT uses port number 1234 at the NAT's public IP address
as the translated endpoint address for the session.
This behavior might be beneficial to some legacy UDP applications
that expect to communicate only using specific UDP port numbers,
but it is not recommended that applications depend on this behavior
since it is only possible for a NAT to preserve the port number
if at most one node on the internal network is using that port number.
.sp
In addition, a NAT should NOT try to preserve the port number in a new session
if doing so would conflict with the goal of maintaining a consistent mapping
between public and private endpoint addresses.
For example, suppose client A at internal port 1234
has established a session with external server S,
and NAT A has assigned public port 62000 to this session
because port number 1234 on the NAT was not available at the time.
Now suppose port number 1234 on the NAT subsequently becomes available,
and while the session between A and S is still active,
client A initiates a new session from its same internal port (1234)
to a different external node B.
In this case, because an active mapping has already been established
between client A's port 1234 and the NAT's public port 62000,
this mapping should be maintained
and the new session should also use port 62000
as the public port corresponding to client A's port 1234.
The NAT should NOT assign public port 1234 to this new session
just because port 1234 has become available:
that behavior would not be likely to benefit the application in any way
since the application has already been operating with a translated port number,
and it would break any attempts the application might make
to establish peer-to-peer connections using the UDP hole punching technique.
.sp
.in 0
.ne 4
6.2. Maintaining Consistent Public/Private Mappings for TCP Ports
.sp
.in 3
For consistency with the behavior of UDP translation,
it is suggested that NATs also maintain a consistent mapping
between private and public (IP address, TCP port number) pairs
for TCP connections,
in the same way as described above for UDP.
Maintaining consistent mappings for TCP ports
facilitates the operation of the simultaneous TCP open technique,
which although not recommended in general for peer-to-peer applications,
may be useful in controlled situations
when the two endpoints are sufficiently well synchronized.
Maintaining TCP endpoint mappings consistently
may also increase the NAT's compatibility with other applications
that initiate multiple TCP connections from the same source port.
.sp
.in 0
.ne 4
6.3. Proxy Protocols
.sp
.in 3
Besides adopting the above recommendations
to make a NAT's basic "transparent-mode" operation
as peer-to-peer friendly as possible,
it is helpful for NATs also to support proxy protocols
that allow applications to request an explicitly managed presence
on the public side of the NAT.
Unfortunately,
several alternative protocols have been proposed
with varying characteristics [SOCKS, RSIP, MIDCOM, UPNP],
and as of this writing none of them
have achieved clear acceptance or dominance in the Internet community.
Furthermore, it is not clear yet how well these protocols will work
in the increasingly common "Twice NAT" situation
where clients are located behind multiple levels of NAT,
especially if the NATs are from different vendors,
support different features and policies,
and are under different administrative domains.
(In the common case, one is owned and managed by the ISP
and the other by the end user.)
For these reasons,
this document makes no attempt to explore this issue in detail
or to recommend specific proxy protocols for NATs to implement.
.sp
.in 0
.ne 4
7. Security Considerations
.sp
.in 3
XXX attacks based on forging source addresses
.sp
.in 3
Using the UDP hole punching technique in peer-to-peer applications
and supporting it in NATs should not create any new security issues.
In particular,
the technique does not require a NAT firewall
to be "promiscuous" in any way about acceping incoming UDP traffic.
As long as outgoing UDP sessions are enabled
and the firewall maintains consistent mappings
between internal and external UDP ports,
the firewall can still filter out all incoming UDP packets except those with
(source IP, source port, destination IP, destination port) tuples
that exactly match those of active sessions initiated from within the enclave.
Filtering incoming traffic aggressively
while maintaining consistent mappings
thus allows a firewall to be "peer-to-peer friendly"
without compromising the standard firewall security principle
of rejecting all unsolicited incoming traffic.
.sp
XXX security issues of relaying or NAT discovery protocols
.sp
It can be argued that maintaining a consistent internal/external port mapping
increases the predictability of traffic crossing the firewall,
by revealing the relationships between different UDP sessions
and hence about the behavior of applications running within the enclave.
This predictability could conceivably be useful to an attacker
in exploiting network- or application-level vulnerabilities.
If the security requirements are so critical
that such subtle information channels are of concern, however,
then the firewall almost certainly should not be configured
to allow unrestricted outgoing UDP traffic in the first place.
Such a firewall should only allow communication
originating from specific applications at specific ports,
or via tightly-controlled application-level gateways.
In this situation there is no hope
of generic, transparent peer-to-peer connectivity across the firewall
(or transparent client/server connectivity for that matter);
the firewall must either implement appropriate application-specific behavior
or disallow communication entirely.
.sp
XXX related to Middlebox Traversal option: forgery
.sp
.in 0
.ne 4
Acknowledgments
.sp
.nf
XXX Dan, Henrik, Dave, ...
.sp
.in 0
.ne 4
References
.sp
.nf
[BIDIR]    Peer-to-Peer Working Group, NAT/Firewall Working Committee,
           "Bidirectional Peer-to-Peer Communication with Interposing
           Firewalls and NATs", August 2001.
           http://www.peer-to-peerwg.org/tech/nat/

[ICE]      J. Rosenberg, "Interactive Connectivity Establishment (ICE):
           A Methodology for Network Address Translator (NAT) Traversal
           for the Session Initiation Protocol (SIP)",
           draft-rosenberg-sipping-ice-00 (Work In Progress),
           February 2003.

[KEGEL]    Dan Kegel, "NAT and Peer-to-Peer Networking", July 1999.
           http://www.alumni.caltech.edu/~dank/peer-nat.html

[MIDCOM]   P. Srisuresh, J. Kuthan, J. Rosenberg, A. Molitor, and
           A. Rayhan, "Middlebox communication architecture and
           framework", RFC 3303, August 2002.

[NAT-APPL] D. Senie, "Network Address Translator (NAT)-Friendly
           Application Design Guidelines", RFC 3235, January 2002.

[NAT-PROT] M. Holdrege and P. Srisuresh, "Protocol Complications
           with the IP Network Address Translator", RFC 3027,
           January 2001.

[NAT-PT]   G. Tsirtsis and P. Srisuresh, "Network Address
           Translation - Protocol Translation (NAT-PT)", RFC 2766,
           February 2000.

[NAT-TERM] P. Srisuresh and M. Holdrege, "IP Network Address
           Translator (NAT) Terminology and Considerations", RFC
           2663, August 1999.

[NAT-TRAD] P. Srisuresh and K. Egevang, "Traditional IP Network
           Address Translator (Traditional NAT)", RFC 3022,
           January 2001.

[RSIP]     M. Borella, J. Lo, D. Grabelsky, and G. Montenegro,
           "Realm Specific IP: Framework", RFC 3102, October 2001.

[SOCKS]    M. Leech, M. Ganis, Y. Lee, R. Kuris, D. Koblas, and
           L. Jones, "SOCKS Protocol Version 5", RFC 1928, March 1996.

[STUN]     J. Rosenberg, J. Weinberger, C. Huitema, and R. Mahy,
           "STUN - Simple Traversal of User Datagram Protocol (UDP)
           Through Network Address Translators (NATs)", RFC 3489,
           March 2003.

[SYM-STUN] Y. Takeda, "Symmetric NAT Traversal using STUN",
           draft-takeda-symmetric-nat-traversal-00.txt (Work In
           Progress), June 2003.

[TCP]      "Transmission Control Protocol", RFC 793, September 1981.

[TEREDO]   C. Huitema, "Teredo: Tunneling IPv6 over UDP through NATs",
           draft-ietf-ngtrans-shipworm-08.txt (Work In Progress),
           September 2002.

[TURN]     J. Rosenberg, J. Weinberger, R. Mahy, and C. Huitema,
           "Traversal Using Relay NAT (TURN)",
           draft-rosenberg-midcom-turn-01 (Work In Progress),
           March 2003.

[UPNP]     UPnP Forum, "Internet Gateway Device (IGD) Standardized
           Device Control Protocol V 1.0", November 2001.
           http://www.upnp.org/standardizeddcps/igd.asp
.fi
.in 3
.sp
.in 0
.ne 5
Author's Address
.sp
.in 3
.nf
Bryan Ford
Laboratory for Computer Science
Massachusetts Institute of Technology
77 Massachusetts Ave.
Cambridge, MA 02139
.sp
Phone: (617) 253-5261
E-mail: baford@mit.edu
Web: http://www.brynosaurus.com/
.fi
.sp
.in 0
Full Copyright Statement
.sp
.in 3
Copyright (C) The Internet Society (2003).  All Rights Reserved.
.sp
This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it
or assist in its implementation may be prepared, copied, published
and distributed, in whole or in part, without restriction of any
kind, provided that the above copyright notice and this paragraph are
included on all such copies and derivative works.  However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to the Internet Society or other
Internet organizations, except as needed for the purpose of
developing Internet standards in which case the procedures for
copyrights defined in the Internet Standards process must be
followed, or as required to translate it into languages other than
English.
.sp
The limited permissions granted above are perpetual and will not be
revoked by the Internet Society or its successors or assigns.
.sp
This document and the information contained herein is provided on an
"AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

